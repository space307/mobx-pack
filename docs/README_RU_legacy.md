# mobx-pack
Библиотека для создания архитектуры приложения с множеством хранилищ на основе библитеки Mobx

# Установка

`npm install mobx-pack --save`

## Вступление

При создании веб-приложений на React встаёт вопрос - какой менеджер состояний использовать 
для разработки приложения, на что стоит обратить внимание. Если никаких специфических требований к приложению нет,
то разумно взять наиболее популярный вариант, например, Redux и это отличный выбор, впрочем если всё же вас 
смущает единое хранилище, много лишнего кода, возможные потери по производительности, сложность деления 
приложения на части с асинхронной подгрузкой, то есть смысл взглянуть на альтернативные варианты.
 
Mobx даёт из коробки, простое api, высокую производительность (в случае если приложение большое и количество обновлений может 
достигать сотен раз в секунду это может быть решающим фактором), возможность использовать привычный ООП подход, 
простой способ связывания состояния с компонентами, однако Mobx не решает проблему организации потока данных и 
деления на части большого приложения. 

Mobx-pack - это маленькая библиотека, которая решает некоторые проблемы построения архитектуры больших приложений, которые 
возникают у разработчика при использовании mobx. 

## Задачи, которые решает mobx-pack

- коммуникация между хранилищами, сервисами, в том числе с загружаемыми асинхронно
- взаимодействие с серверной частью
- порядок инициациализации хранилищ
- разделние ui состоний с бизнес логикой
- организация доступа из одного хранилища к другому
- организация доступа из компонента к  хранилищу
- динамическое создание хранилищ

## Binder
Binder - это класс, который связывает друг с другом сервисы и хранилища приложения. При инициациализации каждый экземпляр сервиса 
привязывается к Binder и передаёт в него опции, в которых описано следующее:

- уникальное имя (bindAs)
- api (ссылки на методы по которым можно обращаться к сервису)
- поля, которые нужно импортировать из других сервисов (importData)
- поля, которые экспортирует сервис (exportData)
- ожидание инициализации других сервисов (waitFor)
и др.

##Сервисы и хранилища (store)

В приложении есть структуры данных, которые описывают бизнесс логику, в частности модели, которые приходят с сервера. 
Эти данные храняться в **сервисах**. Задача сервисов поддержка в актуальном состоянии моделей приложения, обмен данными 
с сервером, с помошью клиента. Экземпляр сервиса является синглтоном.

Также есть состояния, которые относяться к интерфейсу и могут использоваться между разными компонентами, такие состояния
находяться в хранилищах (сторах) и могут создаваться динамически при монтировании компонента.

В mobx-pack есть BaseStore - это класс, который является прототипом для сревисов и хранилищ.

## Жизненный цикл сервиса

Так как сервис синглтон модуль, в котором он описан возврашает по умолчанию экзкмпляр класса сервиса.
Для инициализации сервиса вызывается метод `service.start("entryPoint")`, который возвращает Promise, 
так как сервис стартуя может отправлять запросы для инициации данных. Метод `start` принимает в качестве арумента строковый идентификатор инициатора сервиса. Во время вызыва этого 
метода сервис привязывается к Binder и "сообщает" о себе другим частям приложения.
Так же есть метод `service.stop("entryPoint")` для того, чтобы,  отписаться от Binder, закрыть сокет соединение и т. д.. 
Метод `stop` принимает в качестве арумента строковый идентификатор инициатора сервиса. 
В сервисе есть методы `onStart` и `onStop`, для описания соответствующих действий. 

```javascript
class UserService extends BaseStore {
    
    @observable collection = [];
    
    onStart(){
      return fetchData().then((data)=>{
        collection = data;
      });
    }
    
    onStop(){
      collection = [];
    }
}
```


## Жизненный цикл хранилища (store)
Отличие хранилища от сервиса только в том, что оно создаётся динамически при монтировании компонента и так же автоматически 
удаляется. 

## Connector
Connector - это декоратор обёрнутый в observer (react-mobx), который принимает на вход компонент и опции и возвращает компонент
с дополнительными возможностями. Connector может делать следующее:
- создавать хранилище
- вызывать `start` сервисов и не отрисовыввать компоннет, пока не разрешился Promise
- собирать поля из хранилища и сервисов для передачи в компонент
- передавать api методы из хранилища в компонент

```javascript
export default Connector(
  Component,
  {
    store(){
      return new Store()
    },
    helper(store) {
      return {
        name: userService.name,
        collapsed: store.collapsed,
      };
    },
    services:[ userService ]
  },
);
```
Использование Connector позволяет делать компоненты, которые он оборачивает максимально "тупыми" 
их можно использовать повторно в другом окружении.


## Коммуникации между сервисами
Сервис А может получить значения полей из сервиса Б, но это должно быть описано следующим образом:

```javascript
class BService extends BaseStore {
  
  name = 'Alex';
  
  config = {
    bindAs: B_SERVICE,
    exportData: {
      name: 1
    },
  };
}

class AService extends BaseStore {
  config = {
    bindAs: A_SERVICE,
    importData: {
      [B_SERVICE]: {
        name: 'userName',
      },
    },
  };
}
```
Когда сервисы подписываються в Binder, тот не копирует данные, а создаёт переменую в сервисе A `userName`, которая
является readOnly ссылкой на поле сервиса B `name` , когда сервис отвязывается Binder удаляет ссылки. Так как это ссылка, то
 переменную можно использовать в observe (mobx) и реакция на их изменение будет срабатывать.

Изменить сервис извне можно только вызвав метод callApi, который обратиться к api другого сервиса:

```javascript
class BService extends BaseStore {
  
  name = 'Alex';
  
  config = {
    bindAs: B_SERVICE,
  };
  
  api = {
    setName: this.setName,
  };
  
  @action setName(value){
    this.name = value;
  }
}

class AService extends BaseStore {
  config = {
    bindAs: A_SERVICE,
  };
  
  someMethod(){
    this.callApi(B_SERVICE, 'setName', 'Piter');
  }
}
```
Узнать об инициализации другого сервиса можно с помошью коллбека:

```javascript
class AService extends BaseStore {
  config = {
    bindAs: A_SERVICE,
    onBind:[
      [B_SERVICE, C_SERVICE, ()=>{
          alert('!')
      }]
    ]
  };
}
```

## Порядок инициализации сервисов

Иногда когда один сервис зависит от другого, нужно чтобы `onStart` сервиса вызывался после того как другой сервис
стартовал, для этого можно использовать конструкцию waitFor:

```javascript
class AService extends BaseStore {
  config = {
    bindAs: A_SERVICE,
    waitFor:[B_SERVICE, C_SERVICE]
  };
  onStart(){
    // B_SERVICE and C_SERVICE are already started
    return true;
  }
}
```

## Изменение данных из компонентов
Как уже говорилось выше компоненты через Connector подписываются на изменение стейта приложения observer вызывает 
forceUpdate, когда наблюдаемые поля меняются, но чтобы что то поменять в состоянии, компонент должен вызвать api метод 
хранилища, причём api сервисов недоступно компонентам, только хранилищам и другим сервисам:
```javascript

class Store extends BaseStore {
  config = {
    bindAs: 'Store',
  };
  
  @observable collapsed = false;
  
  api={
    toggle: this.toggle
  };
  
  @action toggle(){
    this.collapsed = !this.collapsed;
  }
}

const Component = ({ collapsed, api }) => (
  <div className={collapsed ? '-collapsed' : ''}>
    <button onClick={api.toggle}>Toggle</button>
  </div>
);

export default Connector(
  Component,
  {
    store() {
      return new Store();
    },
    helper(store) {
      return {
        collapsed: store.collapsed,
      };
    },
  },
);
```

## Схема потока дынных
<img src="docs/shema.png" align="center" width="611" height="657" title="Shema" alt="Shema" />

## Ссылки
- <a href="https://github.com/alexander812/mobx-pack-starter" target="_blank">Boilerplate project</a>
- <a href="https://opencollective.com/mobx/sponsor/0/website" target="_blank">Mobx</a>
